{
  "created_at": "2026-02-25T15:19:42.894859Z",
  "epic": {
    "data": {
      "branch_name": "feat/fn-2-linear-agent-oauth",
      "completion_review_status": "unknown",
      "completion_reviewed_at": null,
      "created_at": "2026-02-25T01:40:36.881606Z",
      "default_impl": null,
      "default_review": null,
      "default_sync": null,
      "depends_on_epics": ["fn-1-add-linear-bot-integration"],
      "id": "fn-2-upgrade-linear-integration-to-linear",
      "next_task": 1,
      "plan_review_status": "unknown",
      "plan_reviewed_at": null,
      "spec_path": ".flow/specs/fn-2-upgrade-linear-integration-to-linear.md",
      "status": "open",
      "title": "Upgrade Linear integration to Linear Agent with OAuth",
      "updated_at": "2026-02-25T04:55:38.636235Z"
    },
    "spec": "# Upgrade Linear Integration to Linear Agent with OAuth\n\n## Overview\n\nUpgrade Terragon's Linear integration from a simple webhook bot (single API key, regex mention detection, ack comments) to a first-class **Linear Agent** with OAuth 2.0, native mentions, agent sessions, and activity tracking.\n\n### Current State (fn-1, implemented)\n- `Comment.create` webhook with HMAC verification\n- Single global `LINEAR_API_KEY` for posting ack comments via `createComment`\n- `LINEAR_MENTION_HANDLE` env var with regex-based mention detection\n- Manual account linking (org ID, user ID, display name, email form)\n- `linearAccount` + `linearSettings` DB tables\n- Feature-flagged behind `linearIntegration`\n\n### Target State (Linear Agent)\n- **OAuth 2.0** with `actor=app` (scopes: `read`, `write`, `app:assignable`, `app:mentionable`)\n- **`AgentSessionEvent` webhooks** as the **canonical trigger** for thread creation:\n  - `created`: Contains `agentSession.id` + `promptContext` \u2014 fires when user mentions/assigns agent\n  - `prompted`: Follow-up input to existing session\n- **`AppUserNotification` webhooks** (inbox notifications): logged but **not** used for thread creation (no `agentSessionId` available)\n- **Agent activities** emitted via `LinearClient.createAgentActivity()`:\n  - Activity content shape: `{ type: \"thought\"|\"action\"|\"response\"|\"error\", body: string }`\n  - NOT the flat `{ type, content }` shape \u2014 content is a typed JSONObject per activity type\n- **Agent sessions**: `externalUrls` (link to Terragon task) via `agentSessionUpdate`\n- **10-second SLA**: Must emit first activity or set `externalUrls` **synchronously** within webhook handler (before returning 200)\n- **Token refresh**: 24-hour access tokens with automatic refresh; DB-level concurrency guard (not in-memory mutex)\n- **Repo detection**: Use `issueRepositorySuggestions(agentSessionId, candidateRepositories)` with candidates from `defaultRepoFullName` + user's recent repos. Fallback to `defaultRepoFullName` if no suggestions.\n\n## Scope\n\n### In Scope\n- New `linearInstallation` table for workspace-level OAuth tokens (nullable `refreshTokenEncrypted`)\n- OAuth callback route + install flow (improving on Slack pattern \u2014 error-first handling)\n- Webhook handler rewrite for `AgentSessionEvent` (primary) + `AppUserNotification` (logging)\n- Agent activity emission during thread lifecycle (time-throttled: max 1/30s per session)\n- Settings UI: OAuth install button + separate \"disconnect account\" vs \"uninstall workspace\"\n- Token refresh with DB-level concurrency guard (optimistic CAS or advisory lock)\n- Documentation updates\n\n### Out of Scope\n- Linear OAuth for per-user identity (v1 keeps manual `linearAccount` linking)\n- Agent `plan` field population from daemon tool calls (future enhancement)\n- `issueNewComment` notification type (too noisy at scale)\n- Agent `elicitation` activity type (not needed for v1)\n- Token revocation on Linear side when disconnecting (just deactivate locally)\n\n## Approach\n\nFollow the **Slack OAuth pattern** with critical fixes:\n- `slackInstallation` table \u2192 `linearInstallation` table\n- `getSlackAppInstallUrl` server action \u2192 `getLinearAgentInstallUrl`\n- `/api/auth/slack/callback` \u2192 `/api/auth/linear/callback`\n- `encryptValue()`/`decryptValue()` for token storage\n\n**Key differences from Slack**:\n- Linear OAuth uses `actor=app` (agent acts as itself, not as user)\n- Linear tokens expire (24h access, refresh tokens) \u2014 Slack tokens don't\n- No OpenID Connect step (user identity stays via manual `linearAccount` linking)\n- **OAuth callback fix**: Handle `error` param BEFORE requiring `code` (Slack has a bug here \u2014 `access_denied` omits `code`)\n- Wrap state decrypt/JSON.parse in try/catch to redirect gracefully on tampered state\n\n**Critical: Webhook event model**:\n- `AgentSessionEvent.created` is the primary trigger for thread creation (always has `agentSession.id`)\n- `AppUserNotification` (issueMention, issueCommentMention, issueAssignedToYou) are inbox signals \u2014 log them, but don't create threads from them (they lack `agentSessionId`)\n- `AgentSessionEvent.prompted` routes follow-up input to existing thread via `agentSessionId`\n\n**Critical: Activity API shapes** (from Linear Agent Interaction docs):\n- `LinearClient.createAgentActivity(input)` where input is `{ agentSessionId, content: { type, body?, action?, parameter?, result? } }`\n- `thought` type: `{ type: \"thought\", body: \"Thinking...\" }`\n- `action` type: `{ type: \"action\", action: \"Running tests\", result?: \"All passed\" }`\n- `response` type: `{ type: \"response\", body: \"Done! Here's what I did...\" }`\n- `error` type: `{ type: \"error\", body: \"Failed: reason\" }`\n\n**Critical: Repo suggestion API**:\n- `issueRepositorySuggestions(agentSessionId, candidateRepositories: [{ fullName, hostname }])` \n- Returns `{ repositoryFullName, hostname, confidence }[]`\n- Must supply `candidateRepositories` \u2014 Linear doesn't auto-detect\n- Candidate strategy: `[defaultRepoFullName]` + user's environments from DB (capped at 10)\n- Fallback: `defaultRepoFullName` from `linearSettings`\n\n## Architecture\n\n```mermaid\nerDiagram\n    linearInstallation {\n        text id PK\n        text organizationId UK\n        text organizationName\n        text accessTokenEncrypted\n        text refreshTokenEncrypted \"nullable\"\n        timestamp tokenExpiresAt\n        text scope\n        text installerUserId FK\n        boolean isActive\n        timestamp createdAt\n        timestamp updatedAt\n    }\n    linearAccount {\n        text id PK\n        text userId FK\n        text linearUserId\n        text organizationId\n    }\n    linearSettings {\n        text id PK\n        text userId FK\n        text organizationId\n        text defaultRepoFullName\n        text defaultModel\n    }\n    linearInstallation ||--o{ linearAccount : \"organizationId\"\n    linearInstallation ||--o{ linearSettings : \"organizationId\"\n    user ||--o{ linearAccount : userId\n    user ||--o{ linearSettings : userId\n```\n\n```mermaid\nsequenceDiagram\n    participant L as Linear\n    participant W as Webhook Route\n    participant H as Handler\n    participant T as Terragon Thread\n    participant D as Daemon\n\n    L->>W: AgentSessionEvent (created)\n    W->>W: Verify signature\n    W->>H: handleAgentSessionCreated(sessionId, promptContext)\n    H->>H: Look up linearInstallation (OAuth token, refresh if needed)\n    H->>H: Resolve linearAccount \u2192 userId\n    H->>L: createAgentActivity({type:\"thought\", body:\"Starting...\"}) [SYNC, <10s]\n    H-->>W: Return 200\n    Note over H: Async via waitUntil()\n    H->>L: issueRepositorySuggestions(sessionId, candidates)\n    H->>T: newThreadInternal(sourceMetadata: {agentSessionId, ...})\n    H->>L: agentSessionUpdate(externalUrls: [taskUrl])\n    T->>D: Start daemon\n    D->>T: daemon events (messages, tool calls)\n    T->>L: createAgentActivity({type:\"action\"}) [throttled: 1/30s]\n    D->>T: result/error\n    T->>L: createAgentActivity({type:\"response\"/\"error\"})\n```\n\n## Quick commands\n\n```bash\n# Type check\npnpm tsc-check\n\n# Run model tests\npnpm -C packages/shared test src/model/linear.test.ts\n\n# Run handler tests\npnpm -C apps/www test src/app/api/webhooks/linear/\n\n# Push schema to dev DB\npnpm -C packages/shared drizzle-kit-push-dev\n```\n\n## Acceptance\n\n- [ ] `linearInstallation` table stores workspace-level OAuth tokens (encrypted, nullable refresh token)\n- [ ] OAuth install flow works: Settings \u2192 Linear consent \u2192 callback \u2192 tokens stored\n- [ ] OAuth callback handles `error` before `code`, wraps state decrypt in try/catch\n- [ ] Webhook handler processes `AgentSessionEvent.created` as primary trigger (creates thread + emits thought)\n- [ ] Webhook handler processes `AgentSessionEvent.prompted` (routes to existing thread)\n- [ ] `AppUserNotification` events logged but don't create threads\n- [ ] First `thought` activity emitted synchronously within webhook handler (<10s SLA)\n- [ ] Agent activities use correct Linear API shapes: `{ type, body/action/result }`\n- [ ] Activity emission throttled: max 1 per 30s per session\n- [ ] Token refresh uses DB-level concurrency guard (not in-memory mutex)\n- [ ] Nullable `refreshTokenEncrypted` \u2014 missing refresh token triggers reinstall prompt\n- [ ] `issueRepositorySuggestions` uses `candidateRepositories` with fallback to `defaultRepoFullName`\n- [ ] Settings UI: separate \"disconnect account\" vs \"uninstall workspace\" actions\n- [ ] `ThreadSourceMetadata` redesigned: required `agentSessionId`, optional `commentId`, `linearDeliveryId` for dedupe\n- [ ] Documentation updated for agent-based flow\n- [ ] All existing tests pass + new tests for handler and model layer\n- [ ] `pnpm tsc-check` passes\n\n## Dependencies\n\n- **fn-1-add-linear-bot-integration** (all 4 tasks done): Provides base `linearAccount`, `linearSettings` tables, model layer, feature flag, and existing webhook infrastructure\n\n## References\n\n- Linear Agent docs: https://linear.app/developers/agents\n- Linear Agent Interaction docs: https://linear.app/developers/agent-interaction\n- Linear OAuth docs: https://linear.app/developers/oauth\n- Linear Agent demo repo: https://github.com/linear/linear-agent-demo\n- Slack OAuth pattern: `apps/www/src/server-actions/slack.ts:37-61`, `apps/www/src/app/api/auth/slack/callback/route.ts`\n- Slack installation schema: `packages/shared/src/db/schema.ts:633-659`\n- Current Linear webhook: `apps/www/src/app/api/webhooks/linear/route.ts`\n- Daemon event handler: `apps/www/src/server-lib/handle-daemon-event.ts`\n- Encryption utilities: `packages/utils/src/encryption.ts`\n"
  },
  "epic_id": "fn-2-upgrade-linear-integration-to-linear",
  "schema_version": 2,
  "tasks": [
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-25T01:41:39.948215Z",
        "depends_on": [],
        "epic": "fn-2-upgrade-linear-integration-to-linear",
        "id": "fn-2-upgrade-linear-integration-to-linear.1",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-upgrade-linear-integration-to-linear.1.md",
        "status": "todo",
        "title": "Schema, env vars, model layer, and token refresh",
        "updated_at": "2026-02-25T05:35:18.086223Z"
      },
      "id": "fn-2-upgrade-linear-integration-to-linear.1",
      "runtime": null,
      "spec": "# fn-2-upgrade-linear-integration-to-linear.1 Schema, env vars, model layer, and token refresh\n\n## Description\nAdd the `linearInstallation` table for workspace-level OAuth tokens, new env vars for OAuth client credentials, model layer CRUD, a token refresh utility with DB-level concurrency protection, type exports, and redesign `ThreadSourceMetadata` for agent sessions.\n\n**Size:** M\n**Files:**\n\n- `packages/shared/src/db/schema.ts` \u2014 add `linearInstallation` table after `linearSettings` (L774)\n- `packages/shared/src/db/types.ts` \u2014 redesign `linear-mention` in `ThreadSourceMetadata`; add `LinearInstallation`/`LinearInstallationInsert` type exports\n- `packages/env/src/apps-www.ts` \u2014 add `LINEAR_CLIENT_ID`, `LINEAR_CLIENT_SECRET`; deprecate `LINEAR_API_KEY`, `LINEAR_MENTION_HANDLE`\n- `packages/shared/src/model/linear.ts` \u2014 add `linearInstallation` CRUD functions\n- `apps/www/src/server-lib/linear-oauth.ts` \u2014 **create** token refresh utility with DB-level guard\n- `apps/www/.env.example` \u2014 add new env vars\n- `packages/shared/src/model/linear.test.ts` \u2014 add tests for new model functions\n\n## Approach\n\n- Follow `slackInstallation` table pattern at `packages/shared/src/db/schema.ts:633-659`\n- `linearInstallation` columns: `id`, `organizationId` (unique), `organizationName`, `accessTokenEncrypted`, `refreshTokenEncrypted` (**nullable** \u2014 some installs may not receive a refresh token), `tokenExpiresAt`, `scope`, `installerUserId` (FK \u2192 user), `isActive`, `createdAt`, `updatedAt`\n- If `refreshTokenEncrypted` is null and token expires, mark installation inactive and surface \"reinstall required\" state\n- Model functions: `upsertLinearInstallation()`, `getLinearInstallationForOrg()`, `deactivateLinearInstallation()`, `updateLinearInstallationTokens()`\n- Token refresh utility: accepts `organizationId`, checks `tokenExpiresAt` (refresh proactively 5 min before expiry). Uses **DB-level optimistic CAS** (`UPDATE ... WHERE tokenExpiresAt = $oldValue`) to prevent concurrent refresh races across serverless instances. If CAS fails, re-read the row (another instance already refreshed). Falls back to `invalid_grant` detection \u2192 mark installation inactive.\n- Env vars: Use `str({ allowEmpty: true, default: \"\" })` pattern matching existing Linear vars at `apps-www.ts:126-128`\n- `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE`: Keep in env validation but mark as deprecated\n- **Type exports**: Add `LinearInstallation` and `LinearInstallationInsert` to `packages/shared/src/db/types.ts` alongside existing type exports\n- **ThreadSourceMetadata redesign** for `linear-mention`:\n  - `agentSessionId: string` \u2014 **required**, the Linear agent session ID\n  - `organizationId: string` \u2014 required (unchanged)\n  - `issueId: string` \u2014 required (unchanged)\n  - `issueIdentifier: string` \u2014 required (unchanged)\n  - `issueUrl: string` \u2014 required (unchanged)\n  - `commentId?: string` \u2014 **optional** (agent sessions from delegation/assignment have no comment)\n  - `linearDeliveryId?: string` \u2014 **new**, webhook delivery ID for idempotency\n\n## Key context\n\n- Linear OAuth token endpoint: `POST https://api.linear.app/oauth/token` with `client_id`, `client_secret`, `grant_type=refresh_token`, `refresh_token`\n- Access tokens expire in 24 hours. Must check `tokenExpiresAt` before each API call\n- `encryptValue()`/`decryptValue()` from `packages/utils/src/encryption.ts` for token storage\n- The `agentSessionId` in `ThreadSourceMetadata` maps a Terragon thread to a Linear agent session for activity emission in task 4\n- DB-level CAS prevents race conditions in Vercel serverless (in-memory mutex only protects one instance)\n- Refresh token may be null: Linear's OAuth response includes `refresh_token` optionally. Handle gracefully.\n## Approach\n\n- Follow `slackInstallation` table pattern at `packages/shared/src/db/schema.ts:633-659`\n- `linearInstallation` columns: `id`, `organizationId` (unique), `organizationName`, `accessTokenEncrypted`, `refreshTokenEncrypted`, `tokenExpiresAt`, `scope`, `installerUserId` (FK \u2192 user), `isActive`, `createdAt`, `updatedAt`\n- Model functions: `upsertLinearInstallation()`, `getLinearInstallationForOrg()`, `deactivateLinearInstallation()`, `updateLinearInstallationTokens()`\n- Token refresh utility: accepts `organizationId`, checks `tokenExpiresAt`, refreshes via `https://api.linear.app/oauth/token` with `grant_type=refresh_token`, encrypts new tokens, updates DB. Use a per-org mutex (simple `Map<string, Promise>`) to prevent concurrent refresh races.\n- Env vars: Use `str({ allowEmpty: true, default: \"\" })` pattern matching existing Linear vars at `apps-www.ts:126-128`\n- `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE`: Keep in env validation but mark as deprecated in comments. Webhook handler (task 3) will stop using them.\n\n## Key context\n\n- Linear OAuth token endpoint: `POST https://api.linear.app/oauth/token` with `client_id`, `client_secret`, `grant_type=refresh_token`, `refresh_token`\n- Access tokens expire in 24 hours. Must check `tokenExpiresAt` before each API call and refresh proactively (e.g., 5 minutes before expiry)\n- `encryptValue()`/`decryptValue()` from `packages/utils/src/encryption.ts` for token storage\n- The `agentSessionId` in `ThreadSourceMetadata` maps a Terragon thread to a Linear agent session for activity emission in task 4\n## Acceptance\n- [ ] `linearInstallation` table created with encrypted token columns, nullable `refreshTokenEncrypted`, unique `organizationId` index\n- [ ] `LinearInstallation` and `LinearInstallationInsert` types exported from `packages/shared/src/db/types.ts`\n- [ ] `ThreadSourceMetadata` for `linear-mention` redesigned: required `agentSessionId`, optional `commentId`, new `linearDeliveryId`\n- [ ] `LINEAR_CLIENT_ID` and `LINEAR_CLIENT_SECRET` added to env validation\n- [ ] `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE` marked deprecated but still functional\n- [ ] Model CRUD: `upsertLinearInstallation`, `getLinearInstallationForOrg`, `deactivateLinearInstallation`, `updateLinearInstallationTokens`\n- [ ] Token refresh uses DB-level optimistic CAS (not in-memory mutex)\n- [ ] Missing refresh token \u2192 mark installation inactive, surface \"reinstall required\"\n- [ ] `.env.example` updated with new vars\n- [ ] Model tests pass: `pnpm -C packages/shared test src/model/linear.test.ts`\n- [ ] Type check passes: `pnpm tsc-check`\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-25T01:41:40.108671Z",
        "depends_on": ["fn-2-upgrade-linear-integration-to-linear.1"],
        "epic": "fn-2-upgrade-linear-integration-to-linear",
        "id": "fn-2-upgrade-linear-integration-to-linear.2",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-upgrade-linear-integration-to-linear.2.md",
        "status": "todo",
        "title": "OAuth flow and callback route",
        "updated_at": "2026-02-25T05:35:48.448362Z"
      },
      "id": "fn-2-upgrade-linear-integration-to-linear.2",
      "runtime": null,
      "spec": "# fn-2-upgrade-linear-integration-to-linear.2 OAuth flow and callback route\n\n## Description\nImplement the OAuth 2.0 install flow for the Linear Agent: a server action that generates the authorization URL, and a callback route that exchanges the code for tokens and stores them encrypted in `linearInstallation`. Fix Slack's callback ordering bug.\n\n**Size:** M\n**Files:**\n\n- `apps/www/src/server-actions/linear.ts` \u2014 add `getLinearAgentInstallUrl` server action\n- `apps/www/src/app/api/auth/linear/callback/route.ts` \u2014 **create** OAuth callback handler\n- `apps/www/src/server-actions/linear.ts` \u2014 update `disconnectLinearAccount` to also deactivate installation\n\n## Approach\n\n- Mirror `getSlackAppInstallUrl` at `apps/www/src/server-actions/slack.ts:37-61`:\n  - `userOnlyAction` wrapper\n  - Encrypted CSRF state: `{ userId, timestamp, type: \"agent_install\" }`\n  - Auth URL: `https://linear.app/oauth/authorize` with params: `client_id`, `redirect_uri`, `response_type=code`, `scope=read,write,app:assignable,app:mentionable` (comma-separated), `actor=app`, `state`\n  - `redirect_uri`: `${nonLocalhostPublicAppUrl()}/api/auth/linear/callback`\n- Callback route at `/api/auth/linear/callback` \u2014 **CRITICAL: Fix Slack's ordering bug**:\n  1. Verify `userId` from session (redirect to notFound if missing)\n  2. **Handle `error` param FIRST** (before checking `code`/`state`) \u2014 `access_denied` may omit `code`\n  3. Validate `state` exists, then **wrap decrypt + JSON.parse in try/catch** \u2014 tampered/invalid state \u2192 redirect to `invalid_state`\n  4. Validate state contents: userId match, <24h expiry\n  5. Validate `code` exists\n  6. Exchange code: `POST https://api.linear.app/oauth/token` with `client_id`, `client_secret`, `code`, `redirect_uri`, `grant_type=authorization_code`\n  7. Response: `access_token`, `token_type`, `expires_in`, `scope`, optional `refresh_token`\n  8. Fetch org info via `LinearClient({ accessToken })` \u2192 `client.organization` for `organizationId` and `organizationName`\n  9. Call `upsertLinearInstallation()` with encrypted tokens (nullable refresh)\n  10. Redirect to `/settings/integrations?integration=linear&status=success&code=agent_installed`\n- Disconnect: Extend `disconnectLinearAccount` per task 5's scope (account vs workspace separation)\n\n## Key context\n\n- Linear OAuth uses `actor=app` which makes the app a first-class workspace participant\n- Unlike Slack, Linear doesn't have separate \"bot install\" vs \"user connect\" OAuth flows\n- Token exchange response includes `expires_in` (seconds) \u2014 compute `tokenExpiresAt = Date.now() + expires_in * 1000`\n- `@linear/sdk` `LinearClient` constructor accepts `{ accessToken }` for OAuth-authenticated clients\n- **Slack callback bug**: Checks `code/state` before `error`, which can 500 when `access_denied` omits `code`. Fix by handling error first.\n- **State validation**: Slack doesn't wrap decrypt in try/catch \u2014 tampered state can cause unhandled exceptions. Fix with explicit error handling.\n## Approach\n\n- Mirror `getSlackAppInstallUrl` at `apps/www/src/server-actions/slack.ts:37-61` exactly:\n  - `userOnlyAction` wrapper\n  - Encrypted CSRF state: `{ userId, timestamp, type: \"agent_install\" }`\n  - Auth URL: `https://linear.app/oauth/authorize` with params: `client_id`, `redirect_uri`, `response_type=code`, `scope=read,write,app:assignable,app:mentionable`, `actor=app`, `state`\n  - `redirect_uri`: `${nonLocalhostPublicAppUrl()}/api/auth/linear/callback`\n- Mirror `/api/auth/slack/callback/route.ts` for callback:\n  - Verify `userId` from session\n  - Decrypt + validate state (userId match, <24h expiry)\n  - Handle `error` param (access_denied \u2192 auth_cancelled redirect)\n  - Exchange code: `POST https://api.linear.app/oauth/token` with `client_id`, `client_secret`, `code`, `redirect_uri`, `grant_type=authorization_code`\n  - Response includes: `access_token`, `token_type`, `expires_in`, `scope`, optional `refresh_token`\n  - Fetch org info via `LinearClient({ accessToken })` \u2192 `client.organization` to get `organizationId` and `organizationName`\n  - Call `upsertLinearInstallation()` with encrypted tokens\n  - Redirect to `/settings/integrations?integration=linear&status=success&code=agent_installed`\n- Disconnect: extend `disconnectLinearAccount` to also call `deactivateLinearInstallation()` for the org\n\n## Key context\n\n- Linear OAuth uses `actor=app` which makes the app a first-class workspace participant (mentionable, assignable)\n- Unlike Slack, Linear doesn't have separate \"bot install\" vs \"user connect\" OAuth flows \u2014 one flow handles everything\n- Token exchange response includes `expires_in` (seconds) \u2014 compute `tokenExpiresAt = Date.now() + expires_in * 1000`\n- The `@linear/sdk` `LinearClient` constructor accepts `{ accessToken }` for OAuth-authenticated clients (vs `{ apiKey }` for API key auth)\n## Acceptance\n- [ ] `getLinearAgentInstallUrl` server action generates correct OAuth URL with `actor=app`, comma-separated scopes, and encrypted state\n- [ ] Callback route handles `error` param BEFORE checking `code`/`state`\n- [ ] Callback wraps state decrypt + JSON.parse in try/catch (tampered state \u2192 redirect, not 500)\n- [ ] Token exchange stores tokens in `linearInstallation` (nullable refresh token supported)\n- [ ] Org info (ID, name) fetched from Linear API after token exchange\n- [ ] Error handling: access_denied, invalid_state, expired state, token exchange failure\n- [ ] Redirect URLs follow pattern: `/settings/integrations?integration=linear&status=...&code=...`\n- [ ] Type check passes: `pnpm tsc-check`\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-25T01:41:40.238468Z",
        "depends_on": ["fn-2-upgrade-linear-integration-to-linear.1"],
        "epic": "fn-2-upgrade-linear-integration-to-linear",
        "id": "fn-2-upgrade-linear-integration-to-linear.3",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-upgrade-linear-integration-to-linear.3.md",
        "status": "todo",
        "title": "Webhook handler rewrite for agent events",
        "updated_at": "2026-02-25T05:36:29.925881Z"
      },
      "id": "fn-2-upgrade-linear-integration-to-linear.3",
      "runtime": null,
      "spec": "# fn-2-upgrade-linear-integration-to-linear.3 Webhook handler rewrite for agent events\n\n## Description\nRewrite the Linear webhook route and handlers to process `AgentSessionEvent` as the **primary trigger** for thread creation, and `AppUserNotification` as logged-only signals. Implement agent activity emission with correct Linear API shapes and 10-second SLA compliance.\n\n**Size:** M\n**Files:**\n\n- `apps/www/src/app/api/webhooks/linear/route.ts` \u2014 rewrite dispatcher for new event types\n- `apps/www/src/app/api/webhooks/linear/handlers.ts` \u2014 rewrite handlers for agent webhook types\n- `apps/www/src/app/api/webhooks/linear/handlers.test.ts` \u2014 rewrite tests for new handlers\n- `apps/www/src/server-lib/linear-agent-activity.ts` \u2014 **create** agent activity emission helpers\n\n## Approach\n\n- **Route rewrite** (`route.ts`):\n  - Keep signature verification (HMAC via `LinearWebhookClient`)\n  - Dispatch by `type` field:\n    - `AgentSessionEvent` \u2192 `handleAgentSessionEvent()` (primary \u2014 creates threads)\n    - `AppUserNotification` \u2192 `handleAppUserNotification()` (log only, no thread creation)\n    - Others \u2192 200 OK, skip\n  - Remove the old `Comment.create` filter at L108\n\n- **`handleAgentSessionEvent` handler** (PRIMARY):\n  - `created` event: **This is the canonical trigger.** Always has `agentSession.id`.\n    1. Look up `linearInstallation` by `organizationId` \u2192 decrypt OAuth token, refresh if needed\n    2. **SYNCHRONOUSLY** (before returning 200): emit `thought` activity via `LinearClient.createAgentActivity({ agentSessionId, content: { type: \"thought\", body: \"Starting work...\" } })`\n    3. Return 200 to Linear\n    4. **ASYNC via `waitUntil()`**: Resolve `agentSession.promptContext` \u2192 extract issue context, resolve `linearAccount` \u2192 userId, use `issueRepositorySuggestions(agentSessionId, candidateRepositories)` for repo detection (candidates from `defaultRepoFullName` + user environments, capped at 10), create thread via `newThreadInternal()`, call `agentSessionUpdate({ externalUrls: [taskUrl] })`\n  - `prompted` event: User follow-up to existing session. Look up thread by `agentSessionId` in `sourceMetadata`. Queue as follow-up message via `appendQueuedMessages`.\n  - Unknown action \u2192 log and skip\n\n- **`handleAppUserNotification` handler** (LOG ONLY):\n  - Parse notification type (`issueMention`, `issueCommentMention`, `issueAssignedToYou`)\n  - Log the event with notification type + organizationId + user info\n  - Do NOT create threads (these lack `agentSessionId`)\n  - Return immediately\n\n- **Agent activity helpers** (`linear-agent-activity.ts`):\n  - Use `LinearClient.createAgentActivity()` from `@linear/sdk` (typed, no raw GraphQL)\n  - Activity content shapes per Linear Agent Interaction docs:\n    - `thought`: `{ type: \"thought\", body: string }`\n    - `action`: `{ type: \"action\", action: string, result?: string }`\n    - `response`: `{ type: \"response\", body: string }`\n    - `error`: `{ type: \"error\", body: string }`\n  - `updateAgentSession({ client, sessionId, externalUrls })` \u2014 set Terragon task link\n  - Error handling: log failures but don't throw (never block thread creation)\n\n- **Repo detection via `issueRepositorySuggestions`**:\n  - Query: `issueRepositorySuggestions(agentSessionId, candidateRepositories: [{ fullName, hostname }])`\n  - Returns: `{ repositoryFullName, hostname, confidence }[]`\n  - Candidate strategy: `[linearSettings.defaultRepoFullName]` + user's environments from DB (capped at 10)\n  - If no suggestions or empty candidates, fall back to `defaultRepoFullName`\n\n- **Idempotency**: Use `linearDeliveryId` from webhook headers/payload as dedupe key in `sourceMetadata`. Check if thread with matching `linearDeliveryId` exists before creating.\n\n- **Self-loop prevention**: Linear natively filters agent's own activities from triggering `AppUserNotification` or `AgentSessionEvent`. Remove the old `containsMention()` regex detection.\n\n## Key context\n\n- `AgentSessionEvent.created` payload: `{ type: \"AgentSessionEvent\", action: \"created\", organizationId, data: { id (sessionId), agentSession: { id, promptContext: { issueId, issueIdentifier, issueTitle, ... } } } }`\n- `AgentSessionEvent.prompted` payload: `{ type: \"AgentSessionEvent\", action: \"prompted\", data: { id, agentActivity: { body } } }`\n- `AppUserNotification` payload: `{ type: \"AppUserNotification\", organizationId, notification: { type, user: { id }, issue: { id } } }` \u2014 NO `agentSessionId`\n- Use `LinearClient({ accessToken })` for all API calls (not `{ apiKey }`)\n- Rate limit: OAuth apps get 500 req/hr. Each webhook handler makes ~3-4 API calls.\n- The 10-second SLA means the `thought` activity MUST be emitted synchronously in the webhook handler before returning 200. Token refresh + activity emission must complete within this budget.\n## Approach\n\n- **Route rewrite** (`route.ts`):\n  - Keep signature verification (HMAC via `LinearWebhookClient` \u2014 agent webhooks use the same signing secret)\n  - Dispatch by `type` field: `AppUserNotification` \u2192 `handleAppUserNotification()`, `AgentSessionEvent` \u2192 `handleAgentSessionEvent()`\n  - Remove the old `Comment.create` filter at L108\n  - Return 200 immediately for both types; async work via `waitUntil()`\n\n- **`handleAppUserNotification` handler**:\n  - Parse `notification.type`: `issueMention`, `issueCommentMention`, `issueAssignedToYou`\n  - Extract `organizationId` from payload, look up `linearInstallation` for OAuth token (replaces global `LINEAR_API_KEY`)\n  - Resolve triggering user: `notification.user.id` \u2192 `linearAccount.linearUserId` \u2192 Terragon `userId`\n  - Feature flag + access tier checks (same as current handler at `handlers.ts:73-95`)\n  - Create `LinearClient({ accessToken: decryptedToken })` for API calls\n  - Use `issueRepositorySuggestions` query with issue ID \u2192 best repo match (confidence-based). Fallback chain: suggestions \u2192 `defaultRepoFullName` from `linearSettings`\n  - Build thread context via `formatThreadContext()` (same as current handler)\n  - Create thread via `newThreadInternal()` with `sourceMetadata` including `agentSessionId`\n  - Post acknowledgment via `agentActivityCreate` mutation (NOT `createComment`) \u2014 emit `thought` type activity\n\n- **`handleAgentSessionEvent` handler**:\n  - `created` event: Contains `promptContext` with issue context. Emit `thought` activity within 10 seconds (CRITICAL SLA). Then create thread.\n  - `prompted` event: User follow-up to existing session. Look up thread by `agentSessionId` in `sourceMetadata`. Queue as follow-up message to existing thread via `appendQueuedMessages`.\n  - Unknown events: log and skip\n\n- **Agent activity emission** (`linear-agent-activity.ts`):\n  - `emitAgentActivity({ client, sessionId, type, content })` \u2014 wrapper around `agentActivityCreate` GraphQL mutation\n  - Activity types: `thought` (initial ack), `action` (progress update), `response` (final result), `error` (failure)\n  - Content is `{ type: \"text\", text: string }` JSONObject\n  - `updateAgentSession({ client, sessionId, externalUrls })` \u2014 set Terragon task link\n  - Error handling: log failures but don't throw (activity emission should never block thread creation)\n\n- **Self-loop prevention**: Linear's agent system natively prevents the app's own activities from triggering `AppUserNotification` webhooks. Remove the old `containsMention()` regex-based detection.\n\n- **Idempotency**: Use `webhookId` from payload as dedup key. Check if thread with matching `sourceMetadata.commentId` already exists before creating.\n\n## Key context\n\n- `AppUserNotification` payload shape (from Linear docs): `{ type: \"AppUserNotification\", organizationId, notification: { type, user: { id, name }, issue: { id, identifier, title, description }, comment?: { id, body } } }`\n- `AgentSessionEvent` payload shape: `{ type: \"AgentSessionEvent\", action: \"created\"|\"prompted\", organizationId, data: { id (sessionId), promptContext?, agentActivity?: { body } } }`\n- `agentActivityCreate` mutation: `mutation { agentActivityCreate(input: { agentSessionId, type, content }) { success } }`\n- `issueRepositorySuggestions` query: `query { issueRepositorySuggestions(issueId: $id) { repository { url, name } confidence } }` \u2014 returns repos sorted by confidence\n- Rate limit: OAuth apps get 500 req/hr. Each webhook handler makes ~3 API calls (activity + issue details + session update). Budget accordingly.\n- The `waitUntil()` pattern at `route.ts:113-117` must be modified: emit first `thought` activity BEFORE returning 200 (or in a fast parallel path within `waitUntil`) to meet 10-second SLA\n## Acceptance\n- [ ] Route dispatches `AgentSessionEvent` and `AppUserNotification` (old `Comment.create` filter removed)\n- [ ] `AgentSessionEvent.created` is the primary trigger \u2014 creates thread + emits thought\n- [ ] `AgentSessionEvent.prompted` routes follow-up to existing thread by `agentSessionId`\n- [ ] `AppUserNotification` events are logged but do NOT create threads\n- [ ] `thought` activity emitted SYNCHRONOUSLY before returning 200 (<10s SLA)\n- [ ] Activity content uses correct Linear API shapes: `{ type: \"thought\", body }`, `{ type: \"action\", action }`, etc.\n- [ ] Uses `LinearClient.createAgentActivity()` (typed SDK, no raw GraphQL)\n- [ ] Per-workspace OAuth token lookup from `linearInstallation` (no global API key)\n- [ ] `issueRepositorySuggestions` called with `candidateRepositories` array; fallback to `defaultRepoFullName`\n- [ ] `externalUrls` set on agent session with Terragon task link\n- [ ] Old regex mention detection removed (`containsMention`, `escapeRegex`)\n- [ ] Idempotency: `linearDeliveryId` used as dedupe key\n- [ ] Handler tests pass: `pnpm -C apps/www test src/app/api/webhooks/linear/`\n- [ ] Type check passes: `pnpm tsc-check`\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-25T01:41:40.349502Z",
        "depends_on": ["fn-2-upgrade-linear-integration-to-linear.3"],
        "epic": "fn-2-upgrade-linear-integration-to-linear",
        "id": "fn-2-upgrade-linear-integration-to-linear.4",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-upgrade-linear-integration-to-linear.4.md",
        "status": "todo",
        "title": "Agent activity lifecycle during thread execution",
        "updated_at": "2026-02-25T05:37:01.205934Z"
      },
      "id": "fn-2-upgrade-linear-integration-to-linear.4",
      "runtime": null,
      "spec": "# fn-2-upgrade-linear-integration-to-linear.4 Agent activity lifecycle during thread execution\n\n## Description\nHook into the daemon event processing pipeline to emit Linear agent activities during thread execution. Time-throttle emissions to max 1 per 30 seconds per session. Use correct Linear activity API shapes.\n\n**Size:** M\n**Files:**\n\n- `apps/www/src/server-lib/handle-daemon-event.ts` \u2014 add Linear activity emission hook\n- `apps/www/src/server-lib/linear-agent-activity.ts` \u2014 extend with `emitLinearActivitiesForDaemonEvent()` orchestrator + throttling\n- `packages/shared/src/model/linear.ts` \u2014 add `getLinearInstallationForThread()` helper\n\n## Approach\n\n- **Detection**: At the top of `handleDaemonEvent()` (after fetching `thread` at L67-75), check if `thread.sourceType === \"linear-mention\"` and `thread.sourceMetadata?.agentSessionId` exists. If so, flag for Linear activity emission.\n- **Time-based throttling**: Track last emission time per `agentSessionId` (simple in-memory `Map<string, number>`). Only emit if \u226530 seconds since last emission. This prevents spamming Linear (500 req/hr limit) and aligns with Linear's guidance that sessions don't need high-frequency updates.\n- **Activity emission during messages**: After processing daemon messages (after L250), if Linear-sourced and throttle allows:\n  - Extract last assistant message text as progress summary\n  - Call `createAgentActivity({ agentSessionId, content: { type: \"action\", action: summary } })` via `waitUntil()`\n- **Completion** (`isDone` at L201): Emit `response` activity (bypass throttle for terminal events)\n  - `createAgentActivity({ agentSessionId, content: { type: \"response\", body: resultSummary } })`\n  - Include cost and duration in body if available\n- **Error** (`isError` at L201): Emit `error` activity (bypass throttle)\n  - `createAgentActivity({ agentSessionId, content: { type: \"error\", body: errorMessage } })`\n- **Token management**: Use `getLinearInstallationForOrg()` + `refreshLinearTokenIfNeeded()` from task 1's utility\n- **Failure isolation**: All Linear activity emissions are wrapped in try/catch and run via `waitUntil()`. A failed emission must never affect thread processing.\n- **Session update on completion**: When thread finishes (in `handleThreadFinish` at L517), update agent session `externalUrls` if not already set.\n\n## Key context\n\n- `handle-daemon-event.ts` processes ALL daemon events for ALL thread types. The Linear hook must be cleanly isolated.\n- `handleThreadFinish` at L517-555 runs async via `waitUntil()`. Linear session completion can piggyback.\n- The `thread` object includes `sourceType` and `sourceMetadata` (with `agentSessionId` after task 1).\n- Activity content shapes (from Linear Agent Interaction docs):\n  - `action`: `{ type: \"action\", action: \"Running tests on auth module\", result?: \"3 tests passed\" }`\n  - `response`: `{ type: \"response\", body: \"Completed task. Created PR #42 with...\" }`\n  - `error`: `{ type: \"error\", body: \"Failed: sandbox timeout after 300s\" }`\n- In-memory throttle map is acceptable here (unlike token refresh) because worst case of lost throttle state = one extra activity emission, which is harmless. No DB-level guard needed.\n- Linear sessions go \"stale\" after ~30 minutes but are recoverable \u2014 low-frequency updates are fine.\n## Approach\n\n- **Detection**: At the top of `handleDaemonEvent()` (after fetching `thread` at L67-75), check if `thread.sourceType === \"linear-mention\"` and `thread.sourceMetadata?.agentSessionId` exists. If so, flag for Linear activity emission.\n- **Activity emission during messages**: After processing daemon messages (after L250), if Linear-sourced:\n  - Extract last assistant message text (if any) as progress summary\n  - Call `emitAgentActivity({ type: \"action\", content: summary })` via `waitUntil()`\n  - Throttle: only emit once per daemon event batch (not per message)\n- **Completion** (`isDone` at L201): Emit `response` activity with final result summary\n  - Extract from the `result` message content or last assistant message\n  - Include cost and duration in activity content if available\n- **Error** (`isError` at L201): Emit `error` activity with error message\n  - Use `customErrorMessage` or generic error description\n- **Token management**: Use `getLinearInstallationForOrg()` + `refreshLinearTokenIfNeeded()` from task 1's utility to get a valid OAuth token before each emission\n- **Failure isolation**: All Linear activity emissions are wrapped in try/catch and run via `waitUntil()`. A failed emission must never affect thread processing.\n- **Session update on completion**: When thread finishes (in `handleThreadFinish` at L517), update agent session status: emit `response` activity to close the session in Linear.\n\n## Key context\n\n- `handle-daemon-event.ts` processes ALL daemon events for ALL thread types (www, slack, github, linear). The Linear hook must be cleanly isolated \u2014 check source type early, branch only for Linear.\n- `handleThreadFinish` at L517-555 runs async via `waitUntil()`. Linear session completion can piggyback on this.\n- The `thread` object (from `getThreadMinimal` at L74) includes `sourceType` and a reference to get `sourceMetadata` from the thread record.\n- `sourceMetadata` for `linear-mention` type is defined at `types.ts:120-126` and will include `agentSessionId` after task 1.\n- Don't emit activities for every single daemon message \u2014 batch per event. A typical daemon event batch has 1-5 messages.\n- The `agentActivityCreate` mutation content is `{ type: \"text\", text: string }`. Keep activity text concise (<500 chars).\n## Acceptance\n- [ ] Linear-sourced threads emit `action` activity on daemon message batches (throttled: max 1/30s)\n- [ ] `response` activity emitted when thread completes (`isDone`) \u2014 bypasses throttle\n- [ ] `error` activity emitted when thread fails (`isError`) \u2014 bypasses throttle\n- [ ] Activity content uses correct shapes: `{ type: \"action\", action }`, `{ type: \"response\", body }`, `{ type: \"error\", body }`\n- [ ] Token refresh used before each activity emission\n- [ ] Activity emission failures are caught and logged (never block thread processing)\n- [ ] Non-Linear threads are completely unaffected (no performance impact)\n- [ ] Time-based throttling prevents Linear rate limit exhaustion\n- [ ] Type check passes: `pnpm tsc-check`\n- [ ] Existing tests pass: `pnpm -C apps/www test`\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    },
    {
      "data": {
        "assignee": null,
        "claim_note": "",
        "claimed_at": null,
        "created_at": "2026-02-25T01:41:40.457873Z",
        "depends_on": [
          "fn-2-upgrade-linear-integration-to-linear.2",
          "fn-2-upgrade-linear-integration-to-linear.3",
          "fn-2-upgrade-linear-integration-to-linear.4"
        ],
        "epic": "fn-2-upgrade-linear-integration-to-linear",
        "id": "fn-2-upgrade-linear-integration-to-linear.5",
        "priority": null,
        "spec_path": ".flow/tasks/fn-2-upgrade-linear-integration-to-linear.5.md",
        "status": "todo",
        "title": "Settings UI, documentation, and cleanup",
        "updated_at": "2026-02-25T06:25:26.634441Z"
      },
      "id": "fn-2-upgrade-linear-integration-to-linear.5",
      "runtime": null,
      "spec": "# fn-2-upgrade-linear-integration-to-linear.5 Settings UI, documentation, and cleanup\n\n## Description\nRewrite the Linear settings UI to use OAuth install button, separate \"disconnect account\" from \"uninstall workspace\", update all documentation for the agent-based flow, and clean up deprecated env vars.\n\n**Size:** M\n**Files:**\n\n- `apps/www/src/components/settings/linear/linear-account-settings.tsx` \u2014 rewrite: OAuth install button + workspace connection status\n- `apps/www/src/components/settings/linear/linear-connect-form.tsx` \u2014 remove or replace manual form\n- `apps/www/src/components/settings/tab/integrations.tsx` \u2014 update Linear section data fetching\n- `apps/www/src/app/(sidebar)/(site-header)/settings/integrations/page.tsx` \u2014 fetch `linearInstallation` data\n- `apps/www/src/server-actions/linear.ts` \u2014 separate disconnect actions\n- `apps/docs/content/docs/integrations/linear-integration.mdx` \u2014 rewrite for agent flow\n- `apps/www/.env.example` \u2014 update Linear section\n- `AGENTS.md` \u2014 update with `linearInstallation` table and agent architecture\n- `apps/docs/content/docs/resources/release-notes.mdx` \u2014 add release notes entry\n- `apps/www/src/lib/constants.ts` \u2014 bump `RELEASE_NOTES_VERSION`\n\n## Approach\n\n- **Settings UI rewrite**:\n  - Mirror Slack's OAuth install pattern at `apps/www/src/components/settings/slack.tsx`\n  - \"Install Linear Agent\" button calls `getLinearAgentInstallUrl` server action \u2192 redirect to Linear OAuth\n  - If `linearInstallation` exists and `isActive`: show workspace name, org ID, connection status, installed date\n  - If `linearInstallation` exists but `isActive=false` (e.g., refresh token expired): show \"Reinstall required\" state\n  - Keep the existing `linearAccount` manual linking form for user identity mapping\n  - Keep existing repo picker + model selector (from `linearSettings`)\n  - **Separate disconnect semantics**:\n    - \"Disconnect my account\" button: deletes `linearAccount` + `linearSettings` for current user only (per-user action)\n    - \"Uninstall workspace\" button: deactivates `linearInstallation` (workspace-wide, requires confirmation). Show impact warning (\"This will disable the Linear agent for all users in this workspace\").\n  - Page server component fetches `linearInstallation` via new model function\n\n- **Server actions** (`server-actions/linear.ts`):\n  - Keep `disconnectLinearAccount` for per-user disconnect (deletes account + settings, NOT installation)\n  - Add `uninstallLinearWorkspace` \u2014 deactivates `linearInstallation` (admin/installer only or confirmation gated)\n\n- **Documentation** (`linear-integration.mdx`):\n  - Rewrite setup steps for agent flow: register Linear app \u2192 configure OAuth \u2192 install via Settings\n  - Update \"How It Works\" to describe agent sessions and activities\n  - Remove references to `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE`\n  - Add Linear app registration instructions (linear.app/settings/api/applications)\n\n- **Env vars cleanup**:\n  - `.env.example`: Add `LINEAR_CLIENT_ID`, `LINEAR_CLIENT_SECRET`. Move `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE` to deprecated block\n  - `AGENTS.md`: Add `linearInstallation` to Database Schema, update Recent Features\n\n- **Release notes**: Follow template at `apps/docs/RELEASE_NOTES_TEMPLATE.md`. Early-access format. Bump `RELEASE_NOTES_VERSION` by 1.\n\n## Key context\n\n- Settings integrations page is a server component: `page.tsx` fetches data, passes to client `integrations.tsx`\n- The manual `linearAccount` form stays for user identity mapping \u2014 workspace OAuth is complementary\n- Slack settings at `apps/www/src/components/settings/slack.tsx` is the template for OAuth install button\n- **Disconnect vs Uninstall**: Slack doesn't have this problem because Slack disconnect doesn't affect workspace install. Linear Agent disconnect is workspace-wide because there's one installation per org. Must separate the actions.\n- Per CLAUDE.md: always bump `RELEASE_NOTES_VERSION` after adding release notes entries\n## Approach\n\n- **Settings UI rewrite**:\n  - Mirror Slack's OAuth install pattern at `apps/www/src/components/settings/slack.tsx`\n  - \"Install Linear Agent\" button calls `getLinearAgentInstallUrl` server action \u2192 redirect to Linear OAuth\n  - If `linearInstallation` exists and `isActive`: show workspace name, connection status, installed date\n  - Keep the existing `linearAccount` manual linking form for user identity mapping (agent OAuth is workspace-level, user mapping is still manual)\n  - Keep existing repo picker + model selector (from `linearSettings`)\n  - \"Disconnect\" button: deactivate `linearInstallation` + delete `linearAccount` + delete `linearSettings`\n  - Page server component fetches `linearInstallation` via new model function\n\n- **Documentation** (`linear-integration.mdx`):\n  - Rewrite \"Setup\" steps for agent flow: register Linear app, install via settings, configure webhook URL\n  - Update \"How It Works\" section to describe agent sessions and activities\n  - Remove references to `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE`\n  - Add setup instructions for Linear app registration (linear.app/settings/api/applications)\n\n- **Env vars cleanup**:\n  - `.env.example`: Add `LINEAR_CLIENT_ID`, `LINEAR_CLIENT_SECRET`. Move `LINEAR_API_KEY` and `LINEAR_MENTION_HANDLE` to a \"deprecated\" comment block\n  - `AGENTS.md`: Add `linearInstallation` to Database Schema, update Recent Features\n\n- **Release notes**: Follow template at `apps/docs/RELEASE_NOTES_TEMPLATE.md`. Early-access format. Bump `RELEASE_NOTES_VERSION` by 1.\n\n## Key context\n\n- Settings integrations page is a server component: `page.tsx` fetches data, passes to client `integrations.tsx`\n- The manual `linearAccount` form stays (for user identity mapping) but workspace OAuth becomes the primary connection method\n- Slack settings UI at `apps/www/src/components/settings/slack.tsx` is the template for the OAuth install button pattern\n- Per CLAUDE.md: always bump `RELEASE_NOTES_VERSION` after adding release notes entries\n## Acceptance\n- [ ] \"Install Linear Agent\" OAuth button visible in Settings when `linearIntegration` flag is enabled\n- [ ] Connected workspace shows name, org ID, status, installed date\n- [ ] \"Reinstall required\" state shown when installation is inactive (expired refresh token)\n- [ ] Manual account linking form still available for user identity\n- [ ] \"Disconnect my account\" removes user's account + settings only (NOT workspace installation)\n- [ ] \"Uninstall workspace\" deactivates installation with confirmation (workspace-wide impact warning)\n- [ ] `linear-integration.mdx` rewritten for agent-based flow\n- [ ] `.env.example` updated with `LINEAR_CLIENT_ID`, `LINEAR_CLIENT_SECRET`; deprecated vars moved\n- [ ] `AGENTS.md` updated with `linearInstallation` table\n- [ ] Release notes entry added (early-access format)\n- [ ] `RELEASE_NOTES_VERSION` bumped by 1\n- [ ] Type check passes: `pnpm tsc-check`\n## Done summary\nTBD\n\n## Evidence\n- Commits:\n- Tests:\n- PRs:\n"
    }
  ]
}
